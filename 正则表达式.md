
# 正则表达式
## 要点
- 匹配位置
- 匹配字符串

## 匹配位置

> ^、$、\b、\B、?=p、(?!p)、(?<=p)、(?<!p)

### ^ ： 匹配行的开头

### $ : 美元符号，匹配行的结尾

### \b :单词的边界，具体讲有三点规则。
        \s：用于匹配单个空格符，包括tab键和换行符；  
        \S：用于匹配除单个空格符之外的所有字符；  
        \d：用于匹配从0到9的数字； 
        \w：用于匹配字母，数字或下划线字符； 
        \W：用于匹配所有与\w不匹配的字符； 
        . ：用于匹配除换行符之外的所有字符。
-  \w和\W之间的位置
-  ^与\w之间的位置
-  \w与$之间的位置

### \B :非单词的边界，也就是\b反着来的意思，它的规则如下
- \w与\w之间的位置
- \W与\W之间的位置
- ^与\W之间的位置
- \W与$之间的位置    

### (?=p) : 符合p子模式前面的那个位置。换句话说是，有一个位置，紧跟其后需要满足p子模式。也有一个学名叫正向先行断言。

❤️xxx_love_study_1.mp4


### (?!p) : (?=p)反过来的意思，可以理解为(?=p)匹配到的位置之外的位置都是属于(?!p)的，它也有一个学名叫负向先行断言。

x❤️x❤️x❤️_❤️l❤️o❤️v❤️e❤️_❤️s❤️t❤️u❤️d❤️y❤️_❤️1❤️.❤️m❤️p❤️4❤️

### (?<=p) : 符合p子模式后面(注意(?=p)表示的是前面)的那个位置。换句话说是，有一个位置，其前面的部分需要满足p子模式。

xxx❤️_love_study_1.mp4

### (?<!p) : (?<=p)反过来的意思，可以理解为(?<=p)匹配到的位置之外的位置都是属于(?<!p)的，

❤️x❤️x❤️x_❤️l❤️o❤️v❤️e❤️_❤️s❤️t❤️u❤️d❤️y❤️_❤️1❤️.❤️m❤️p❤️4❤️


## 匹配字符串

### 横向匹配
- 一个正则可匹配的字符串的长度不是固定的，可以是多种情况，通过量词+、*、?、{m,n}，可实现横向匹配

### 纵向匹配
- 一个正则匹配的字符串，具体到某一位字符时，可以不是某个确定的字符串，可以有多种可能，实现方式是字符组( 其实多选分支|也可以实现 )

### 字符组匹配
- 不要被名字给糊弄了，虽然他叫做字符组，但其实只是代表一个字符的可能性

### 范围表示法
- [123456abcdefABCDEF] => [1-6a-fA-F]

### 排除字符组
- 某位字符可以是任何东西，但是就是不能是xxx, 使用^符号

### 量词
1. {m,} // 至少出现m次
2. {m} // 出现m次
3. ? // 出现0次或者1次，等价于{0,1}    
4. + // 至少出现1次,等价于{1,} 
5. * // 出现一次,等价于{0,}  

### 贪婪匹配 VS 惰性匹配
 > 贪婪匹配(greedy)：它会匹配尽可能多的字符。它首先看整个字符串，如果不匹配，对字符串进行收缩；遇到可能匹配的文本，停止收缩，对文本进行扩展，当发现匹配的文本时，它不着急将该匹配保存到匹配集合中，而是对文本继续扩展，直到无法继续匹配 或者 扩展完整个字符串，然后将前面最后一个符合匹配的文本(也是最长的)保存起来到匹配集合中。所以说它是贪婪的。找到匹配的之后还是继续查找，若找到不合适的则返回最后一个匹配合适的。 

 > 惰性匹配(lazy)：它会匹配尽可能少的字符，它从第一个字符开始找起，一旦符合条件，立刻保存到匹配集合中，然后继续进行查找。所以说它是懒惰的。
 光看上面的定义。找到匹配的之后，立即返回结果，然后再继续查找
- 正则本身是贪婪的，会尽可能的多匹配符合模式的字符

### 多选分支
- 一个模式可以实现横向和纵向的模糊匹配，而多选分支可以支持多个子模式任选其一，形式是(p1|p2|p3)

### 括号的作用 
- 括号的作用是提供了分组(括号内的正则是一个整体，即提供子表达式)，便于我们引用它

#### 分组
#### 分支结构
#### 分组引用
- 通过括号创建子表达式，可以进行数据提取和强大的替换操作，也可以通过js来引用分组内容
  - 提取数据
  - 数据替换
  - 反向引用


来源：https://juejin.cn/post/7021672733213720613
相关书籍：《JavaScript正则表达式迷你书》